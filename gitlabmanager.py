import requests
import urllib3
import time


class Gitlabmanager:

    def __init__(self, repo_list, configs):
        self.repo_list = repo_list
        self.target_group = configs["target_group"]

        self.mr_list = configs["mr_list"]

        self.dib_approvals = configs["dib_approvals"]
        self.dsit_approvals = configs["dsit_approvals"]
        self.approvals_required = configs["approvals_required"]

        self.template = configs["template"]

        self.gitlab_token = configs["gitlab_token"]
        self.gitlab_url = configs["gitlab_url"]

        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    def process_git2git(self):
        urls = []

        # collect users ids
        dib_approvals_ids = self.find_users_in_gitlab(self.dib_approvals)
        dsit_approvals_ids = self.find_users_in_gitlab(self.dsit_approvals)
        mr_list_ids = self.find_users_in_gitlab(self.mr_list)

        for project in self.repo_list:
            project_name = project[0]
            variables = project[1]

            print("Creating project...")
            project_id, project_url = self.import_project_from_template(project_name)
            if project_id and project_url:
                urls.append(project_url)
            else:
                print("Exit with code 1.")
                exit(1)

            print("Sleep 5 seconds...")
            time.sleep(5)

            # set gitlab ci vars
            for k, v in variables.items():
                self.set_gitlab_ci_variable(project_id, k, v)

            # approval_rules with DIB && DSIT approvers
            if dib_approvals_ids:
                self.set_approval_rules(project_id, "DIB", dib_approvals_ids)
            else:
                print("NO DIB USERS IN PROJECT/GROUP")

            if dsit_approvals_ids:
                self.set_approval_rules(project_id, "DSIT", dsit_approvals_ids)
            else:
                print("NO DSIT USERS IN PROJECT/GROUP")

            if mr_list_ids:
                self.set_protected_branches(project_id, "master", mr_list_ids)
            else:
                print("NO MR USERS IN PROJECT/GROUP")

            print("\n\n")

        return urls

    def import_project_from_template(self, project_name):
        print(f"IMPORT mirroring-{project_name} \n TEMPLATE: {self.template}")

        if self.template == "pull":
            template_url = "devops_infrastructure/mirroring-from-vendor/templates/template-test.git"
        else:
            print(f"Undefined template {self.template}")

        url = f"{self.gitlab_url}/api/v4/projects"

        headers = {"PRIVATE-TOKEN": self.gitlab_token}

        data = {
            "namespace_id": self.target_group,
            "name": f"mirroring-{project_name}",
            "import_url": f"https://gitlab-ci-token:{self.gitlab_token}@pivlab.space/{template_url}",
            "visibility": "private",
        }

        r = requests.post(url, headers=headers, data=data, verify=False)

        print(f"STATUS_CODE: {r.status_code}")

        if r.status_code in range(200, 299):
            new_project_id = r.json()["id"]
            new_project_url = r.json()["web_url"]

            return new_project_id, new_project_url

        print("Project create failed!")

        return None, None

    def set_gitlab_ci_variable(self, project_id, variable, value):
        print(f"SET VARIABLE: {variable} with VALUE: {value}")

        url = f"{self.gitlab_url}/api/v4/projects/{project_id}/variables"
        headers = {"PRIVATE-TOKEN": self.gitlab_token}
        data = {
            "variable_type": "env_var",
            "key": variable,
            "value": value,
            "protected": False,
            "masked": False,
            "hidden": False,
            "raw": False,
            "environment_scope": "*",
            "description": "auto generated by script",
        }

        r = requests.post(url, headers=headers, data=data, verify=False)

        print(r.status_code)

    def find_users_in_gitlab(self, usernames):
        user_ids = []

        print(f"FINDING USERS {usernames} IN GITLAB:")

        for username in usernames:
            url = f"{self.gitlab_url}/api/v4/users/?username={username}"

            headers = {"PRIVATE-TOKEN": self.gitlab_token}

            r = requests.get(url, headers=headers, verify=False)

            if r.status_code in range(200, 299) and r.json():
                print("user: ", r.json()[0]["username"], "id: ", r.json()[0]["id"])

                user_ids.append(r.json()[0]["id"])
            else:
                print(f"USER {username} NOT FOUND IN GITLAB, skip this")

        return user_ids

    def set_approval_rules(self, project_id, rule_name, approval_user_ids):
        print(f"SET APPROVAL_RULE: {rule_name} with APPROVERS: {approval_user_ids}")

        url = f"{self.gitlab_url}/api/v4/projects/{project_id}/approval_rules"
        headers = {"PRIVATE-TOKEN": self.gitlab_token}
        data = {
            "approvals_required": self.approvals_required,
            "name": rule_name,
            "user_ids": approval_user_ids,
        }

        r = requests.post(url, headers=headers, json=data, verify=False)

        print(f"RULE: {rule_name} STATUS_CODE: {r.status_code}")

    def set_protected_branches(self, project_id, branch, allowed_user_ids):
        base_url = f"{self.gitlab_url}/api/v4/projects/{project_id}/protected_branches"
        headers = {"PRIVATE-TOKEN": self.gitlab_token}

        data = {
            "name": branch,
            "push_access_level": 30,  # 30 = Developers
            "merge_access_level": 30,
            "allowed_to_merge": [{"user_id": user_id} for user_id in allowed_user_ids],
            "allowed_to_push": [{"user_id": user_id} for user_id in allowed_user_ids],
        }

        r = requests.delete(
            url=f"{base_url}/{branch}", headers=headers, json=data, verify=False
        )

        time.sleep(5)

        print(f"UNPROTECTED BRANCH: {branch}", r.status_code)

        post_url = base_url
        r = requests.post(post_url, headers=headers, json=data, verify=False)

        print(f"PROTECTED BRANCH: {branch}", r.status_code)
